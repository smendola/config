###############################################################
### ALIASES AND FUNCTIONS FOR INTERACTIVE USE
###############################################################


# Clears the scrollback buffer, not just the current screen
alias cls='tput reset'

function bd () {
    cd "$OLDPWD"
}

alias grep='grep --color=auto'
alias start=cygstart
alias rm='rm -i'
alias type='builtin type -f'
alias undos=dos2unix

dev()
{
    cd $WS/vagrant/dev-env; vagrant ssh -- -Y "$@"
}

# This implementation replaces an older one that used while/cd..
function upto()
{
    if [[ $# != 1 ]]
    then
        echo "Usage: upto [DIRNAME]"
        echo "       chdir upward (..) until at dir named DIRNAME, or fail"
        return 1
    fi
    local pwd=$(pwd)
    local target=$1
    local full_target=${pwd/\/$target\/*/\/$target}
    if [[ $full_target = $pwd ]]
    then
        echo "Not found in upward path: $target"
        return 1
    else
        cd $full_target
    fi
}

alias pp='echo $PATH | tr : \\12'

function ,() {
    eval "$@" | 1,000
}

# E.g. = 2+2
= () { echo "$@" | bc -l; }

function ec() {
  # Note: emacsclient goes with emacs, NOT xemacs
  # The equivalent (and not as good) for xemacs is gnuclient
  
  # Connect to running emacs, or start emacs as server and then connect
  # -nw means TTY mode
  emacsclient -a '' -nw "$@"
}

alias e=npp
alias s=sublime

alias deref=readlink

# run commands, displaying the command at as the terminal's title,
# e.g. 
function wt () {
    title "$1" "$@"
    "$@" ;# no need to use "eval"; that actually causes problems
}

function tp () {
  TITLE_PREFIX="$@"
}

function lth () {
    ls -lt "$@" | head
}

alias pp='echo $PATH | tr : \\12'

function y () {
    echo "Nothing else to remove.  Pay attention!"
}


# Comma-format numbers
# Usage: , <cmd> [args]
# e.g.: 
# $ , ls -l
# $ , du
# This causes large numbers in the output of cmd to be formatted with commas,
# like this: 123,456
# If possible, it preserves columns by eating extra whitespace
# to the left of the number to make up for the insertion of the commas
# It won't eat the last remaining space that separates the number
# from whatever precedes it.
function  , ()
{
   "$@" | 1,000
}

# Usage: <cmd> | 1,000
#        1,000 < <textfile>
# e.g: 
# $ ls -l | 1,000
# Note: normally, you would not invoke 1,000 directly, but through , (above)
function 1,000 ()
{
    sed -e ': start' -e 's/\( \?\)\( \?\)\([0-9]\{1,\}\)\([0-9]\{3\}\)/\1\3,\4/g' -e 't start'
}

function jgrep ()
{
    local what="$(echo "$1" | tr / .)";
    local where="$2";
    test -z "$where" && where=.;
    if [ -d "$where" ]; then
        /bin/find "$where" -name '*.jar' -exec sh -c "jar tf \$(dos {} ) | grep -q $what" \; -print;
    elif [ -e "$where" ]; then
        jar tf "$where" | grep "$what";
    else
        echo "jgrep: No such file or directory: $where"
    fi
}

function unx() {
    # e.g. /c/Program Files
    cygpath -ua "$1"
}
function dos() {
    # e.g. C:\PROGRA~1
    cygpath -da "$1"
}
function win() {
    cygpath -wa "$1"
}
function mix() {
    # e.g. C:/Program Files
    cygpath -ma "$1"
}

alias jmeter='(cd $TOOLS_DIR/jmeter/bin; nohup ./jmeter.sh &)'


function cygsetup() {
    curl -\# -o /setup.exe 'http://cygwin.com/setup-x86.exe'
    chmod +x /setup.exe
    cmd /c start $(dos /setup.exe) "$@"
}

function sts() {
    if [ -z "$DISPLAY" ]
    then
      echo "DISPLAY needs to be set"
      return 1
    elif xset q > /dev/null
    then
		(/opt/sts-bundle/sts-3.6.3.SR1/STS > sts.log 2>&1 &)
    else
      echo "Problem with display?"
      return 1
    fi
}

function idea() {
    if [ -z "$DISPLAY" ]
    then
      echo "DISPLAY needs to be set"
      return 1
    elif xset q > /dev/null
    then
        detach /opt/IDEA/bin/idea.sh 
    else
      echo "Problem with display?"
      return 1
    fi
}

function mqst() {
    mvn -q -DskipTests "$@"
}
function mqsti() {
    mqst install "$@"
}
function ntd() {
  $WS/tools/deploy.sh "$@"
}
function nti() {
  $WS/tools/install-ng.sh "$@"
}


function skysync-testenv () {
    RSYNC_CONNECT_PROG='nc localhost 11873' rsync --compress-level=9 -av $@
}

function skysync-apphost () {
    RSYNC_CONNECT_PROG='nc localhost 10873' rsync --compress-level=9 -av $@
}

function skysuite()
{
  (
    cd $WS/test/robotframework/src/main/suite
    skysync-testenv \
        --exclude=Configuration.txt \
        --exclude='*.pyc' \
        --exclude='*.bak' \
        ./ ::suite/
  )
}

function skylogs () {
    mkdir -p ~/Robot_Logs
    if [[ $1 = -s ]]
    then
        skysync-testenv "skytap::suite/results/*.png" ~/Robot_Logs
        shift
    fi
    
    skysync-testenv \
        "skytap::suite/pybot-args.txt" \
        "skytap::suite/results/output.xml" \
        "skytap::suite/results/log.html" \
        "skytap::suite/results/report.html" \
        ~/Robot_Logs &&
    start ~/Robot_Logs/report.html
}

function fixtty() {
    stty sane erase ^H
}

function jenkins() {
    (title Jenkins "JENKINS on 9090"; cd $JENKINS_HOME; java -jar jenkins.war --httpPort=9090)
}

type stty > /dev/null 2>&1 || stty() {
    echo -n
}

function tomcat() {
    shutdown.sh > /dev/null 2>&1
    sleep 2
    /bin/rm /c/tools/tomcat/logs/*
    title Tomcat Tomcat
    catalina.sh jpda run 2>&1 | tee /c/tools/tomcat/logs/CONSOLE_OUT
}

# Cause an annotation entry to show up in Fiddler
function anno() {
    anno=$(echo $* | tr ' ' '_')
    curl -s --proxy http://localhost:8888 "http://localhost/anno?$anno" > /dev/null; 
}

function clear-m2() {
    if [[ $# > 0 ]]
    then
        for pkg in "$@"
        do
             command rm -rfv ~/.m2/repository/${pkg//.//}
        done
    else
        command rm -rfv ~/.m2/repository/
    fi
}

# these pertain to version management of this and other cygwin environment
# files.  Git normally could not manage a dir such as ~, but wrapped this
# way it does a fine job.
# Use:
#  dots diff
#  dots pull origin master
#  dots commit -a -m "whatever"
#  dots push origin master
# you get the gist.
alias dots='git --git-dir=$HOME/.config.git/ --work-tree=$HOME'

function syncdots()
{
    (dots status -s | grep -q '.' && echo ci && dots commit -a -m "${1:-bla}" || echo NO CO && true) && 
    echo pull &&  dots pull origin master && 
    echo push &&  dots push
}

alias ride='(python -c "from robotide import main; main()"&)'
alias rebot='rebot.bat'
# Use the whole width of the terminal for pybot output
alias pybot='command pybot -W $(( $(tput cols) - 2 ))'

# show all colors available with ansi escapes
# show them both as BG and as FG
function palette() {
    for code in {000..255}; do
        print -n -P -- "${BG[$code]}[$code]"
    done
    print -P -- "$BG[000]"
    print ""
    for code in {000..255}; do
        print -n -P -- "${FG[$code]}[$code]"
    done
    print -P -- "$BG[000]"
}

# WIP XML processing
# options are like xmlstarlet sel, however, default is --text; override
# that with -X for XML.  Also the first -t is implied.
# Usage: xsl [-X] [-t] <xmlstarlet-sel-t-options>
# eg. accurev show wspaces -fx | xsl -m //Element -v @Name -n
function xsl() {
    if [[ $# = 0 || $1 = -h ]]
    then
        echo "Usage: xsl [-X] [-t] <options>"
        echo "XSL transformation using xmlstarlet sel"
        echo "       -X XML output; default is text"
        echo "       -t introduces template; this is optional and implied"
        echo ""
        echo "From xmlstarlet help:"
        xmlstarlet sel --help | sed -n -e '/^Syntax/,/^There can be/p' | head -n -2
        return
    fi
    
    local mode
    if [[ $1 = -X ]]
    then
        mode=--xml-decl
        shift
    else
        mode=--text
    fi
    if [[ $1 = -t ]]
    then
        shift
    fi
    xmlstarlet sel $mode -I -D -t "$@"
}

function xpath() {
    if [[ $1 = -x ]]
    then
        shift
        xmlstarlet sel -R -I -D -t -c "$1" -n "$@"
    else
        xmlstarlet sel -t -v "$1" -n "$@"    
    fi
}

# Run a Java program in debug mode, so as to be attached in debugger
# Usage: jpda [-p PORTNUM] [-s] other java args...
#       -p PORTNUM  use PORTNUM, default 9000
#       -s          suspend and and wait for debugger to connect
# Example: jpda -s com.my.Code arg arg
function jpda() {
    local port=9000
    local suspend=n
    
    while getopts :sp: OPTNAME "$@"
    do
        case $OPTNAME in
         p) port=$OPTARG;;
         s) suspend=y;;
         *) break;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    
    java -Xdebug -Xrunjdwp:"server=y,transport=dt_socket,address=$port,suspend=$suspend" "$@"
}

function merge_ini() {
    diffmerge --merge --result $HOME/ng-install.ini --title2 MERGED \
        $HOME/ng-install.ini \
        $HOME/install.ini-common-ancestor.ini \
        $WS/tools/sw-ng-installer/setup/install.ini
}

alias tdc='tree -AdC -I target'
alias tcf='tree -ACF --dirsfirst'

###############################################
#### BASH SPECIFIC ALIASES                 ####
#### Stuff you mostly get for free in ZSH  ####
###############################################

# Testing $SHELL gives false results. Try something else.
if [[ $(type print) != *builtin ]]
then

    function prat() { 
        if [[ $TERM == emacs ]]; then
            return;
        fi

        PRAT=$*;
        local attr_list='0';
    #    local attr_list2='0;31;47;7'
        local attr_list2='41'
        local shlvl;
        local title;
        local prompt;
        local remote;

        for attr in $*;
        do
            attr_list="$attr_list;$attr";
        done

        if [[ $SHLVL > 1 ]]; then
            shlvl=" [$SHLVL]";
        fi
        if [[ ! -z $SSH_CONNECTION ]]
        then
            remote=" [REMOTE]"
        fi

        prompt="\n\[\033[${attr_list}m\] \h: \w \[\033[${attr_list2}m\]\$(curbranch_bracketed)$shlvl$remote\[\033[0m\] \n\$ ";
        PS1=$prompt
    }

    # set the terminal window title bar label 
    # Usage: title IGNOREDPARAM WINDOW_TITLE
    title () {
            if [[ "$DISABLE_AUTO_TITLE" = "true" ]] || [[ "$EMACS" = *term* ]]
            then
                    return
            fi
            if [[ "$TERM" = screen* ]]
            then
                    echo -ne "\ek$1e\\"
            elif [[ "$TERM" = xterm* ]] || [[ $TERM = rxvt* ]] || [[ "$TERM_PROGRAM" = "iTerm.app" ]]
            then
                    echo -ne "\e];$2$\a"
                    #echo -ne "\e]2;$2\a"
                    echo -ne "\e]1;$1\a"
            fi
    }


    function curbranch()
    {
        if git branch > /dev/null 2>&1 
        then
            echo $(git branch | grep '^[*]' | cut -c 3-)
        fi
    }

    function curbranch_bracketed()
    {
        __git_ps1 ' (%s) '
        
        #local cb=$(curbranch)    
        #if [[ $cb ]]
        #then
        #    echo " [$cb]"
        #fi
    }

fi

# mods    - show modified files in ws
# mods -o - show all outgoing changes
# mods -d - show "default group" (whatever that means; kept + and locally modified?)
# Additional args, if any, are dirs to stat; default is .
mods()
{
    local opt;
    local els;
    case "$1" in
      -[ao]) opt=--outgoing; shift;;
      -d) opt=-d; shift;;
      *)  opt=-m;;
    esac
    if [[ $# = 0 ]]
    then
        set .
    fi
    ar stat $opt -R -fl "${@}"
}

# Or, how about this:
# downside is that if ar stat errors out, err msg gets parsed as xml
#mods()
#{
#    if [[ $1 = -a ]]
#    then
#        accurev stat --outgoing -fx | xsl -m //element -v @location -n
#    else
#        accurev stat -m -fx | xsl -m //element -v @location -n
#    fi
#}


list-ws()
{
    where=${1:-.}
    find $where -maxdepth 1 -type d -name \*.git -prune -o -exec test -f {}/super/pom.xml \; -print -prune
}

# Usage:
#   ws        - cd into workspace ($WS), and show the path
#   ws DIR    - set WS=DIR, and cd into it; only for this shell
#   ws -p DIR - set WS=DIR, persistently, that is re-link ~/ng -> DIR
#               future shells will therefore use WS=DIR as well
#               (but not any other shells that are already running!)
ws()
{
    if [[ $# != 0 ]]
    then
    
        if [[ $# = 2 && $1 = -p ]]
        then
            shift
            echo "Persisting switch to workspace $1 for this and new shells"
            rm -f ~/ng
            mklink "$1" ~/ng
        else
            echo "*** Selecting workspace $1 for THIS SHELL ONLY."
            echo "    (Use -p to select persistently.)"
        fi
        
        export WS=$(readlink -f "$1")
        # trailing / is important; see comment near WORKSPACE= in .zshrc
        export WORKSPACE=$(mix $WS/)
    fi
    
    # zsh does something funky with prompt string %~
    # it's preferable to cd ~/ng over cd $WS if possible
    if [[ $(readlink -f ~/ng) = $WS ]]
    then
        cd ~/ng
    else
        cd "$WS"
    fi
    echo ${WS/$HOME/\~}
}

my-server()
{
    MY_NG_SRV=${1:-localhost:2080}
    API1=http://$MY_NG_SRV/api/v1
}

mark()
{
    if [[ $# = 0 ]]
    then
        echo "Usage: $0 text that will show up in tomcat log"
        return 1
    fi
    # $*, NOT $@; urlencode needs one param
    api1 GET /system/marker/$(urlencode "$*") -o /dev/null -uadmin:password1X!
}

extract-log-range()
{
    local start_re="\\(start \\)*$1"
    local end_re="\\(end \\)*${2:-END}"
    local log_file=${3:-/c/tools/tomcat/logs/CONSOLE_OUT}
    sed -n -e "/MARKER: $start_re/,/MARKER: $end_re/IP" "$log_file"
}

api1-login()
{
    local un=${1:-admin}
    local pw=${2:-password1X!}
    api1 post login --data-urlencode "username=$un" --data-urlencode "password=$pw"
}

# WIP will likely evolve incompatibly
api1()
{
    if [[ $# < 2 ]]
    then
        echo "Usage: $0 get|put|post|delete RESOURCE [CURL_OPTS ...]"
        echo "        RESOURCE is path after /api/v1, w/ or w/o leading slash"
        echo "        CURL_OPTS ahh... read the man page! :)"
        echo ""
        echo "E.g.: $0 get /users/count"
        echo " Or:"
        echo "      $0 get users/count"
        echo " More complex:"
        echo "     $0 get domains \\"
        echo "        --data-urlencode query='[\"MATCH\", bla bla bla]' \\"
        echo "        --data pageSize=10"
        return 1
    fi
    local verb=$(echo -n $1 | tr a-z A-Z)
    local resource=${2#/}
    shift 2
    
    local extra_get=""
    if [[ $verb == GET ]]
    then
        # --data* opts override -X GET, force POST behavior
        # --get overrides the override :) 
        extra_get="--get"
    fi
    curl -s -X $verb $extra_get --url $API1/$resource "$@"
    echo ""
}

alias stripansi='perl -ple "s/\033\[(?:\d*(?:;\d+)*)*m//g;"'

gdiff()
{
   diffuse "%@"
}


detach()
{
  ( "$@" & ) > /dev/null 2>&1
}

tt()
{
	detach terminator
}

alias aptitude='sudo aptitude'
alias apt-get='sudo apt-get'
alias docker='sudo docker'
alias synaptic='sudo synaptic'
alias service='sudo service'
alias initctl='sudo initctl'
alias bum='sudo bum'
alias reboot='sudo reboot'
alias halt='sudo halt'
alias poweroff='sudo poweroff'
alias shutdown='sudo shutdown'

